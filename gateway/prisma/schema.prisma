generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String   @id @default(uuid())
  email       String   @unique
  password    String   
  name        String
  companyName String
  
  apiKey         String   @unique @default(uuid())
  monoApiKey     String?
  monoPublicKey  String?
  webhookUrl     String?

  monoCustomerId String?

  isVerified  Boolean  @default(false)
  otp         String?
  otpExpiry   DateTime?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  applicants     Applicant[]
  refreshTokens  RefreshToken[]
}

model RefreshToken {
  id          String   @id @default(uuid())
  tokenHash   String   @unique
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt   DateTime
  revoked     Boolean  @default(false)
  createdAt   DateTime @default(now())

  @@index([userId])
  @@index([tokenHash])
}



model Applicant {
  id             String    @id @default(uuid())
  firstName      String
  lastName       String
  email          String
  phone          String?
  bvn            String?

  fintechId      String
  fintech        User      @relation(fields: [fintechId], references: [id])

  bankAccounts   BankAccount[]
  applications   Application[]

  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([fintechId])
  @@index([email])
}


model BankAccount {
  id             String   @id @default(uuid())
  monoAccountId  String   @unique
  institution    String?
  accountName    String?
  accountNumber  String?
  balance        Int?

  // Async enrichment data stored as Mono webhooks/jobs complete
  incomeData            Json?    // from mono.events.account_income webhook
  statementInsightsData Json?    // from Mono enrichments job (polled via insightsJobId)
  insightsJobId         String?  // jobId returned when we trigger the insights job
  enrichmentStatus      String   @default("PENDING") // PENDING | READY | FAILED

  applicantId    String
  applicant      Applicant @relation(fields: [applicantId], references: [id], onDelete: Cascade)

  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  transactions   Transaction[]
  @@index([applicantId])
  @@index([enrichmentStatus])
}


model Application {
  id                String    @id @default(uuid())
  applicantId       String
  
  amount            Int
  tenor             Int
  interestRate      Float     @default(5.0)
  purpose           String?
  
  status            String    @default("PENDING")
  score             Int?
  decision          Json?

  explanation       String?   @db.Text      
  bankAccountIds    String[]
  
  approvedAmount    Int?
  approvedTenor     Int?
  monthlyPayment    Float?
  
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  processedAt       DateTime?
  
  applicant         Applicant @relation(fields: [applicantId], references: [id], onDelete: Cascade)
  
  @@index([applicantId])
  @@index([status])
}


model WebhookDelivery {
  id            String    @id @default(uuid())
  fintechId     String
  event         String
  payload       Json
  webhookUrl    String
  status        String    @default("PENDING")
  attempts      Int       @default(0)
  statusCode    Int?
  errorMessage  String?
  lastAttemptAt DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([fintechId])
  @@index([status])
}


model Transaction {
  id             String      @id @default(uuid())
  accountId      String
  bankAccount    BankAccount @relation(fields: [accountId], references: [monoAccountId], onDelete: Cascade)
  amount         Int
  type           String      
  description    String
  date           DateTime
  category       String?     
  createdAt      DateTime    @default(now())
  
  @@index([accountId])
}